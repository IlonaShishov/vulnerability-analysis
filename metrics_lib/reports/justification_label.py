import pandas as pd

class JustificationLabelMetrics:

    JUSTIFICATION_PROMPT = """
        The summary provided below (delimited with XML tags), generated by the software agent named Vulnerability
        Analysis for Container Security, evaluates a specific CVE (Common Vulnerabilities and Exposures) against the
        backdrop of a software package or environment information. This information may include a Software Bill of
        Materials (SBOM), source code, and dependency documentation among others related to environments such as
        container images. Vulnerability Analysis for Container Security's role is to analyze this data to ascertain if the CVE
        impacts the software environment, determining the necessity for a patch.

        Your task is to review Vulnerability Analysis for Container Security's analysis and classify the situation into
        one of the following categories based on the described scenario:
        - false_positive: The association between the software package and the CVE is incorrect, either due to an
        erroneous package identification or a mismatched CVE.
        - code_not_present: The software product is unaffected as it does not contain the code or library that harbors
        the vulnerability.
        - code_not_reachable: During runtime, the vulnerable code is not executed.
        - requires_configuration: The exploitability of this issue depends on whether a specific configuration option is
        enabled or disabled. In this case, the configuration is set in a manner that prevents exploitability.
        - requires_dependency: Exploitability is contingent upon a missing dependency.
        - requires_environment: A specific environment, absent in this case, is required for exploitability.
        - compiler_protected: Exploitability hinges on the setting or unsetting of a compiler flag. In this case, the
        flag is set in a manner that prevents exploitability.
        - runtime_protected: Mechanisms are in place that prevent exploits during runtime.
        - perimeter_protected: Protective measures block attacks at the physical, logical, or network perimeters.
        - mitigating_control_protected: Implemented controls mitigate the likelihood or impact of the vulnerability.
        - uncertain: Not enough information to determine the package's exploitability status.
        - vulnerable: the package is actually vulnerable to the CVE and needs to be patched.

        Response only with the category name.
        <summary>{{summary}}</summary>
        """
 
    def __init__(self):

        self.name = "Justification Label Metrics"

        self.metrics = {
            "Faithfulness": {},
            "ResponseRelevancy": {},
            "SummarizationScore": {},
            "AspectCritic_representativeness": { 
                "name": "*aspect_critic_representativeness", 
                "definition": "Does the classification in the submission strongly reflect the intent of the given summary?"
            },
            "AspectCritic_relevance": { 
                "name": "*aspect_critic_relevance",
                "definition": "Is the submission highly relevant to the summary, focusing on its most important aspects?"
            },
            "AspectCritic_validity": { 
                "name": "*aspect_critic_validity",
                "definition": "Does the submission exactly match one of the predefined valid categories listed in the prompt?"
            }
        }

    def get_datasets(self, test_data):
        datasets = {}
        for case_id, case_data in test_data.items():
            dataset = []
            for item in case_data:   
                output = item["output"] 
                justification_label = output["justification"]["label"]
                summary = output["summary"]
                data = {
                    "user_input": self.JUSTIFICATION_PROMPT.format(summary=summary),
                    "response": justification_label,
                    "reference": summary,
                    "reference_contexts": [summary],
                    "retrieved_contexts": [summary]
                }
                dataset.append(data)
            datasets[case_id] = dataset
        return datasets

class VulnerabilityConsistencyReport:
    
    def __init__(self, test_data):
        self.name = "Vulnerability Consistency"
        
        self.data = test_data
        self.report_table = pd.DataFrame({'ID': list(self.data.keys())})

        self._evaluate()

    def _evaluate(self):
        for case_id, case_data in self.data.items():
            affected_count = 0
            unknown_count = 0
            not_affected_count = 0
            for idx, item in enumerate(case_data):
                output = item["output"]
                label = output["justification"]["label"]
                match label:
                    case "vulnerable":
                        self.report_table.loc[self.report_table['ID'] == case_id, f'OP{idx + 1}'] = "Affected"
                        affected_count+=1
                    case "uncertain":
                        self.report_table.loc[self.report_table['ID'] == case_id, f'OP{idx + 1}'] = "Unknown"
                        unknown_count+=1
                    case _:
                        self.report_table.loc[self.report_table['ID'] == case_id, f'OP{idx + 1}'] = "Not Affected"
                        not_affected_count+=1
            total_count = affected_count + not_affected_count + unknown_count
            self.report_table.loc[self.report_table['ID'] == case_id, 'Answer Consistency'] = max(
                    affected_count, not_affected_count, unknown_count
                ) / total_count

class JustificationLabelConsistencyReport:
    
    def __init__(self, test_data):
        self.name = "Justification Label Consistency"

        self.data = test_data
        self.report_table = pd.DataFrame({'ID': list(self.data.keys())})
        
        self._evaluate()

    def _evaluate(self):
        for case_id, case_data in self.data.items():
            label_count = {}
            for idx, item in enumerate(case_data):
                output = item["output"]
                label = output["justification"]["label"]
                self.report_table.loc[self.report_table['ID'] == case_id, f'OP{idx + 1}'] = label
                label_count[label] = label_count.get(label, 0) + 1
            self.report_table.loc[self.report_table['ID'] == case_id, 'Answer Consistency'] = max(label_count.values()) / sum(label_count.values())